#+TITLE: Autograd modules

* Training the Lennard Jones parameters

There is a database of DFT calculations of Ar in [[./argon.db]]. Here is a brief description of the database. It contains five structures at three different volumes each. For each volume and structure the atoms were randomly displaced many times, and the energy and forces were computed using DFT (Vasp).

#+BEGIN_SRC python :results output org
from collections import Counter
import ase.db

db = ase.db.connect('argon.db')
data = db.select()

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.items():

        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.items():
    vals = list(set(v))

    if len(vals) <= 5:
        val = ", ".join(str(e)[:5] for e in vals)
        print('{0:5}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:5s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
keyword         value           139 calculations total
------------------------------------------------------
i    :0, 1, 2, 3, 4, etc...
structure: fcc, hcp, sc, diamo, bcc
f    : 0.9, 1.0, 1.1
#+END_SRC


We can use the built in pydoc:autograd.misc.optimizers.adam optimizer to find the best set of parameters. We have to provide an initial guess.

#+BEGIN_SRC python :results output org drawer
import autograd.numpy as np
from dap.ag.lennardjones import energy
from autograd.misc.optimizers import adam
from autograd import grad

import matplotlib.pyplot as plt

import ase.db
db = ase.db.connect('argon.db')

known_energies = [row.energy for row in db.select()]
all_positions = [row.positions for row in db.select()]
all_cells = [row.cell for row in db.select()]

# Initial guess
params = {'epsilon': 0.1, 'sigma': 3.5}

def objective(params, step):
    energies = [energy(params, pos, cell) for pos, cell in zip(all_positions, all_cells)]
    errs = np.array(energies) - np.array(known_energies)
    return np.mean(np.abs(errs))

max_steps = 251
loss_goal = 0.01

def callback(params, step, gradient):
    if step % 100 == 0:
        loss = objective(params, step)
        print(f"step {i * max_steps + step:4d} objective {loss:1.4f} {params}")

for i in range(10):
    if objective(params, None) <= loss_goal:
        break

    params = adam(grad(objective), params,
                  step_size=0.001, num_iters=max_steps, callback=callback)


print(f'Final params = {params} with a MAE of {objective(params, None):1.2e}')

# Save for reuse later. autograd saves the params as 0d arrays, which are not
# serializable, so we cast them as floats here.
import json
with open('argon-lj.json', 'w') as f:
    f.write(json.dumps({'sigma': float(params['sigma']),
                        'epsilon': float(params['epsilon'])}))
#+END_SRC

#+RESULTS:
:RESULTS:
step    0 objective 0.6260 {'epsilon': array(0.1), 'sigma': array(3.5)}
step  100 objective 0.0236 {'epsilon': array(0.00399268), 'sigma': array(3.42282772)}
step  200 objective 0.0168 {'epsilon': array(0.00638201), 'sigma': array(3.43248715)}
step  251 objective 0.0166 {'epsilon': array(0.00631611), 'sigma': array(3.44008306)}
step  351 objective 0.0141 {'epsilon': array(0.00604479), 'sigma': array(3.54264976)}
step  451 objective 0.0107 {'epsilon': array(0.00569821), 'sigma': array(3.65304244)}
Final params = {'epsilon': array(0.00527079), 'sigma': array(3.71124126)} with a MAE of 9.04e-03
:END:

Now that we have fitted it, we can reuse it.

#+BEGIN_SRC python :results output org drawer
import json
import matplotlib.pyplot as plt
import ase.db
import numpy as np
from dap.ag.lennardjones import energy

with open('argon-lj.json') as f:
    params = json.loads(f.read())

db = ase.db.connect('argon.db')

plt.subplot(121)
for structure, spec in [('fcc', 'b.'),
                        ('hcp', 'r.'),
                        ('bcc', 'g.'),
                        ('diamond', 'gd'),
                        ('sc', 'bs')]:

    ke, pe = [], []
    for row in db.select(structure=structure):
        ke += [row.energy]
        atoms = row.toatoms()

        pe += [energy(params, atoms.positions, atoms.cell)]
    plt.plot(ke, pe, spec, label=structure)

plt.plot([-0.1, 0], [-0.1, 0], 'k-', label='parity')
plt.legend()
plt.xlabel('DFT')
plt.ylabel('LJ')

err = np.array(ke) - np.array(pe)

plt.subplot(122)
plt.hist(err)
plt.xlabel('error')
plt.tight_layout()
plt.savefig('ag-lj.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./ag-lj.png]]

See also: http://kitchingroup.cheme.cmu.edu/blog/2017/11/19/Training-the-ASE-Lennard-Jones-potential-to-DFT-calculations/
